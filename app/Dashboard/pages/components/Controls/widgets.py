# This file is for the tailor-made widgets for controls including OPTIONS dropdown, addon function for generating a dict for the combined input of payment arrangement.
from dash import Dash
from distutils.log import debug
from re import A, S
from dash import dcc, html, Input, Output, State, callback_context, MATCH, ALL, Patch, callback  # type: ignore
from dash.exceptions import PreventUpdate
import dash_bootstrap_components as dbc
import dash_mantine_components as dmc
from dash_iconify import DashIconify

from app.Dashboard.pages.components.toolkit import to_dropdown_options, suffix_for_type
from app.Dashboard.assets.ids import *
from app.Dashboard.pages.components import amortization_types
import json


# Addons function for the payment arrangement.
# For further information, please refer to the documentation of the addon function in the file Amort\test\ADDON.py.
# code of the color: https://useaxentix.com/docs/general/colors/

# addon inputs function.
def addon(
        # Type need to be indicated within ['prepay', 'subsidy'] to distinguish the different dropdowns.
        type: str,
        # dropdown_list: list,
        placeholder: str,
        pattern_matching=False,
        disabled: bool = False,
        index= "",
        dropdown_label= None,
):
    """
    The addon function is used to generate a dict for the combined input of payment arrangement.
    The "suffix_for_type()" function is imported from the toolkit module to make format of the id match the type which specified in the argument, to distinguish the different dropdowns.

    Note that the there is no an argument for the dropdown list. It is needed to be generated by the callback function, 
    of which the id of the output is 'suffix_for_type(ADDON.DROPDOWN.LIST, type)' if the argument of the pattern_matching is off, 
    otherwise the id of the output is '{'index': type, 'type': suffix_for_type(ADDON.DROPDOWN.LIST, type)}' if the argument of the pattern_matching is on.

    For example, the following codes show the callback function for the dropdown list while the pattern_matching is on:

    @callback(
        Output({'index': ALL, 'type': suffix_for_type(ADDON.DROPDOWN.LIST, type)}, 'data'),
        Input(suffix_for_type(LOAN.TERM), 'value'),
    )
    def update_dropdown_list(term: int):
        return term

    """

    layout = html.Div(
        [
            dcc.Store(id={"index": index, "type": suffix_for_type(ADDON.DROPDOWN.LIST, type)},
                      data=0
                      ),
            dcc.Store(id={"index": index, "type": suffix_for_type(ADDON.DISABLED, type)}, data=disabled),
            # That's the outcome what we want.
            dcc.Store(id={"index": index, "type": suffix_for_type(ADDON.MEMORY, type)}, data={}),
            dmc.Group(
                children= [
                    dmc.Select(
                                data= [],
                                id={"index": index, "type": suffix_for_type(ADDON.DROPDOWN.MENU, type)},
                                disabled=disabled,
                                size= 'md',
                                style= {
                                    'width': 80,
                                    # 'color': '#4C9F85'
                                },
                                clearable= True,
                                placeholder= 'Time',
                    ),
                    dmc.NumberInput(
                       id= {"index": index, "type": suffix_for_type(ADDON.INPUT, type)},
                       style={
                           "width": 100,
                           },
                       value= 0,
                       size= 'md',
                       step= 0.01,
                       min= 0,
                       max= 100,
                       precision= 2,
                       type= 'float',
                    ),
                    dmc.ButtonGroup(
                        [
                            dmc.Button(
                                id={"index": index, "type": suffix_for_type(ADDON.ADD, type)},
                                variant= 'gradient',
                                gradient={"from": "indigo", "to": "cyan"},
                                children= DashIconify(
                                    icon= 'icon-park-twotone:add',
                                ),
                                disabled= disabled,
                                size= 'md',
                                style= {
                                    'width': 55,
                                },
                            ),
                            dmc.Button(
                                id={"index": index, "type": suffix_for_type(ADDON.DELETE, type)},
                                variant= 'gradient',
                                gradient={"from": "grape", "to": "pink", "deg": 35},
                                children= DashIconify(icon= 'tabler:trash'),
                                disabled= disabled,
                                size= 'md',
                                style= {
                                    'width': 55,
                                },
                            )
                        ]
                    )
                ],
                spacing= 0,
                style= {
                    'display': 'flex',
                },
                align= 'start',
                position= 'left',
            ),
            dbc.Collapse(
                id= {"index": index, "type": suffix_for_type(ADDON.COLLAPSE, type)},
                children=[
                    dbc.Card(
                        children= [dbc.CardBody(id= {"index": index, "type": suffix_for_type(ADDON.NEW, type)})],
                        style= {
                            'height': '150px',
                            'overflow': 'scroll',
                        }
                    )
                ],
                is_open=False,
                style= {
                    'width': '100%',
                }
            ),
        ],
    )


##1 Control the disabled status of the input and the add button.
    @callback(
        Output({"index": MATCH, "type": suffix_for_type(ADDON.INPUT, type)}, 'disabled', allow_duplicate= True),
        Output({"index": MATCH, "type": suffix_for_type(ADDON.DROPDOWN.MENU, type)}, 'disabled', allow_duplicate= True),
        Output({"index": MATCH, "type": suffix_for_type(ADDON.ADD, type)}, 'disabled', allow_duplicate= True),
        Output({"index": MATCH, "type": suffix_for_type(ADDON.DELETE, type)}, 'disabled', allow_duplicate= True),
        Input({"index": MATCH, "type": suffix_for_type(ADDON.DISABLED, type)}, 'data'),
        prevent_initial_call=True
    )
    def control_disabled(disabled):
        return disabled, disabled, disabled, disabled

##2 update the data in dmc.Select
    @callback(
        Output({"index": MATCH, "type": suffix_for_type(ADDON.DROPDOWN.MENU, type)}, 'data'),
        Input({"index": MATCH, "type": suffix_for_type(ADDON.MEMORY, type)}, 'data'),
        Input({"index": MATCH, "type": suffix_for_type(ADDON.DROPDOWN.MENU, type)}, 'value'),
        Input({"index": MATCH, "type": suffix_for_type(ADDON.DROPDOWN.LIST, type)}, 'data'),
        prevent_initial_call=True
    )
    def update_Select_list(
        memory,
        _,
        lst
    ):
        if lst and len(lst[-1]) > 0:
            registered = [element for element in range(int(lst[-1][0]), int(lst[-1][-1]) + 1)]
        else:
            registered = []
        list_items= [{"value": registered_item, "label": f"{registered_item}"} for registered_item in registered if str(registered_item) not in memory]
        return list_items
    
##4 callback for add button.
    @callback(
        [
            Output({"index": MATCH, "type": suffix_for_type(ADDON.NEW, type)}, 'children', allow_duplicate= True),
            Output({"index": MATCH, "type": suffix_for_type(ADDON.INPUT, type)}, 'value', allow_duplicate= True),
            # Output({"index": MATCH, "type": suffix_for_type(ADDON.DROPDOWN.MENU, type)}, 'label', allow_duplicate= True),
            Output({"index": MATCH, "type": suffix_for_type(ADDON.DROPDOWN.MENU, type)}, 'value', allow_duplicate= True),
            Output({"index": MATCH, "type": suffix_for_type(ADDON.MEMORY, type)}, 'data', allow_duplicate= True),
            # Output({"index": MATCH, "type": suffix_for_type(ADDON.COLLAPSE, type)}, 'is_open', allow_duplicate= True),
        ],
        Input({"index": MATCH, "type": suffix_for_type(ADDON.ADD, type)}, 'n_clicks'),
        [
            # State({"index": MATCH, "type": suffix_for_type(ADDON.DROPDOWN.MENU, type)}, 'label'),
            State({"index": MATCH, "type": suffix_for_type(ADDON.DROPDOWN.MENU, type)}, 'value'),
            State({"index": MATCH, "type": suffix_for_type(ADDON.INPUT, type)}, 'value'),
            State({"index": MATCH, "type": suffix_for_type(ADDON.MEMORY, type)}, 'data'),
            # State({"index": MATCH, "type": suffix_for_type(ADDON.COLLAPSE, type)}, 'is_open'),
        ],
        prevent_initial_call=True
    )
    def add_items(
        _,
        selected_time,
        # current_label,
        current_input,
        memory,
        # is_open,
    ):
        patched_item = Patch()
        if selected_time and current_input:
            memory[str(selected_time)] = float(current_input)
            sorted_memory= {}
            for k in [str(sorted_key) for sorted_key in sorted([int(key) for key in memory.keys()])]: 
                sorted_memory[k]= memory[k]
            patched_item= [new_checklist_item(_, type= type, index= index, result= {k: v}) for (k, v) in sorted_memory.items()]
            return patched_item, 0, 0, memory, #is_open
        else:
            raise PreventUpdate
        
    # mark the done items
    @callback(
        Output({"index": MATCH, "type": suffix_for_type(ADDON.OUTPUT, type)}, "style", allow_duplicate= True),
        Input({"index": MATCH, "type": "done"}, "value"),
        prevent_initial_call=True
    )
    def mark_done(done):
        if not done:
            style = {"display": "inline-block",
                     "margin": "5px", "margin-right": "5px"}
        else:
            style = {
                "display": "inline-block",
                "margin": "5px",
                "text-decoration": "line-through",
                "color": "#888",
                "margin-right": "5px",
            }
        return style

##5 callback for delete button
    @callback(
        Output({"index": index, "type": suffix_for_type(ADDON.NEW, type)}, 'children', allow_duplicate= True),
        Output({"index": index, "type": suffix_for_type(ADDON.MEMORY, type)}, 'data'),
        Input({"index": index, "type": suffix_for_type(ADDON.DELETE, type)}, 'n_clicks'),
        State({'index': ALL, 'type': 'done'}, 'value'),
        State({"index": index, "type": suffix_for_type(ADDON.MEMORY, type)}, 'data'),
        prevent_initial_call=True
    )
    def delete_items(
        _, 
        state, 
        memory, 
        # is_open
        ):
        patched_item = Patch()
        values_to_remove = []
        if memory:
            for i, value in enumerate([s for s in state if s]): # Errors occurred when multiple components were deployed and "None" were added in the state list. To address this problem, I filtered the state list to remove all instances of "None" and only kept the instances of "done".  
                if value:
                    values_to_remove.insert(0, i)
            for i in values_to_remove:
                del patched_item[i]
                # remove corresponding items from the memory.
                del memory[list(memory.keys())[i]]
            return patched_item, memory, #is_open
        else:
            raise PreventUpdate
##6 collapse
    @callback(
        Output({"index": index, "type": suffix_for_type(ADDON.COLLAPSE, type)}, 'is_open'),
        Input({"index": index, "type": suffix_for_type(ADDON.MEMORY, type)}, 'data'),
        State({"index": index, "type": suffix_for_type(ADDON.COLLAPSE, type)}, 'is_open')
    )
    def update_collapse(data, is_open):
        if len(data) == 0:
            return False
        else:
            return True


    return layout


def new_checklist_item(triggered_index, type, index, result):
    return html.Div(
        [
            dcc.Checklist(
                options=[
                    {"label": "", "value": "done"}
                ],
                id={
                    "index": triggered_index,
                    "type": "done"
                },
                style={"display": "inline-block",
                       "margin-right": "5px"},
            ),
            html.Div(
                [
                    html.Li('Apply', style={
                            'display': 'inline-block',
                            "margin-right": "5px",
                            }
                            ),
                    html.Li([*result.values()][-1],
                            style={
                                'display': 'inline-block',
                                "margin-right": "5px",
                    }
                    ),
                    html.Li('from the', style={
                            'display': 'inline-block',
                            "margin-right": "5px",
                            }
                    ),
                    html.Li([*result][-1],
                            style={
                                'display': 'inline-block',
                                "margin-right": "1px",
                            }
                    ),
                    html.Li(('st' if c == "1" 
                                  else ('nd' if c == "2" else ('rd' if c == "3" else 'th'))) if len(c := [*result.keys()][-1]) == 1 else ('st' if c[-1] == '1' else ('nd' if c[-1] == '2' else ('rd' if c[-1] == '3' else 'th'))), 
                            style={
                            'display': 'inline-block',
                            "margin-right": "5px",
                            },
                    ),
                ],
                id={
                    "index": triggered_index,
                    "type": suffix_for_type(ADDON.OUTPUT, type)
                },
                style={
                    "display": "inline-block",
                    "margin": "5px",
                    'margin-right': '5px',
                    "maxWidth": "400px"
                },
            ),
        ],
    )


# build a refeshable dropdown that can refresh the options when the refresh button is clicked.
def refreshable_dropdown(
        label: str,
        # ['prepay', 'subsidy'] Consider the case of duplicate ids.
        type: str = 'prepay',
        placeholder: str = 'Choose methods of the payment',
        options: dict = amortization_types,
        disabled: bool = False,
        index= "",
        width= 280,
        **kwargs
):
    """
    There are two dropdown components in the layout: one for the payment options and the other for refreshing the options accordingly. 
    Note that since there are two kinds of types, 'prepay' and 'subsidy', 
    the IDs of the components are formatted as {'index': type, 'type': original ID of the component} in order to separate the types within the layout.
    """
    dropdown = html.Div(
        [
            html.Div(
                [
                    dmc.MultiSelect(
                        label="Repayment methods",
                        id={"index": index, "type": suffix_for_type(ADVANCED.DROPDOWN.OPTIONS, type)},
                        placeholder="Select method for repayment",
                        value= [*options],
                        data=[*options],
                        size= 'sm',
                        style={
                            "width": width + 10, 
                            "marginBottom": 5,
                        },
                    ),
                    dmc.Button(
                        children="Refresh",
                        id={"index": index, "type": suffix_for_type(ADVANCED.DROPDOWN.BUTTON, type)},
                        variant="gradient",
                        gradient={"from": "teal", "to": "blue", "deg": 60},
                        n_clicks= 0,
                    ),
                ],
            ),
        ],
    )

    # Refresh the Dropdown of the Payment options
    @callback(
        Output({"index": index, "type": suffix_for_type(ADVANCED.DROPDOWN.OPTIONS, type)}, 'value'),
        Input({"index": index, "type": suffix_for_type(ADVANCED.DROPDOWN.BUTTON, type)}, 'n_clicks'),
    )
    def refresh_options(_: int):
        if _> 0:
            return [*options]
        else:
            raise PreventUpdate
    return dropdown


# py -m app.Dashboard.pages.components.Controls.widgets
if __name__ == "__main__":
    app = Dash(__name__, 
           external_stylesheets=[dbc.themes.BOOTSTRAP, dbc.icons.BOOTSTRAP], 
           suppress_callback_exceptions=True
           )

    app.layout = html.Div(
        [
            refreshable_dropdown(
                label='Test for refreshable dropdown'),
            html.Hr(),
            html.H6('Test for addon'),
            addon(
                type='test',
                # dropdown_list=[1, 2],
                # dropdown_label="Time",
                placeholder="Input the timepoint",
            )
        ]
    )
    app.run_server(debug=True)
